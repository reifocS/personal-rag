Observables vs. Signals... Et pourquoi pas les deux?
 Â Sipios devient TheodoÂ FinTech, lâentitÃ© experte Services Financiers du groupe Theodo 
ClientsOffresMobile Wealth ManagementFintechÂ Due DiligenceMVPÂ at scaleConception et design UX/UIProgramme d'APIsationFinTech as a serviceExpertisesReactJSOpen BankingSpring BootKotlinBlog

Tech

BusinessCarriÃ¨re

Equipe


Nous rejoindreContactObservables vs. Signals... Et pourquoi pas les deux? 7 minutesMis Ã  jour le18/7/2024Share this postDÃ©couvrez comment Angular 17 rÃ©volutionne la gestion de l'asynchronisme avec les Signals. Explorez les cas d'usage et les Ã©quivalences entre Observables et Signals pour faciliter la migration et optimiser vos applications.#Angular#Observables#SignalsLÃ©o MerranTech LeadIntroductionPour les adeptes dâAngular, la sortie des Signals Ã©tait une feature trÃ¨s attendue. Depuis Angular 17, ils ont stabilisÃ© leurs utilisations et de plus en plus de personnes, initialement rÃ©ticentes, se voient converti Ã  leur utilisation. Cela Ã  pour effet de crÃ©er deux clans pour la gestion de lâasynchronisme dans les applications web : les Observables VS les Signals.Mais ce serait se fourvoyer que de penser que les deux ne peuvent pas cohabiter. En rÃ©alitÃ©, les Signals ne sont pas la solution Ã  prendre dans 100% des cas. Dans certaines situations, les Observables resteront la meilleure solution. Je vais donc faire au travers de cet article des recommandations sur les cas dâusages et des Ã©quivalences pour faciliter la migration de lâun Ã  lâautre.âQuand utiliser un Signal ?En pratique, les Signals sont plus simples Ã  mettre en place et Ã  utiliser. Ils seront donc privilÃ©giÃ©s dans la plupart des situations (moins de code, meilleure lisibilitÃ© et plus de comprÃ©hension,â¦). Ils sont principalement utilisÃ©s dans l'interface utilisateur et leur valeur peut Ãªtre entiÃ¨rement modifiÃ©e via set ou mise Ã  jour sur la base d'une valeur prÃ©cÃ©dente avec update. Cette fonctionnalitÃ© est un gros plus. En effet, les Subjects permettaient dâinjecter une valeur manuellement dans lâobservable, mais elle ne pouvait pas dÃ©pendre de la valeur prÃ©cÃ©dente. Avec les Signals, on peut mettre Ã  jour en fonction de la valeur actuelle.Pour comprendre, partons dâun cas simple :let myValue = 0;On va pouvoir la modifier et lâutiliser dans le template comme on le souhaite, mais vu quâelle nâest pas rÃ©active en lâÃ©tat, la valeur ne sera pas mise Ã  jour. Câest lÃ  que les Signals rentrent en jeu. Ils vont permettre de wrapper cette valeur pour notifier en cas de mise Ã  jour. Ainsi, je peux faire :mySignal = signal(1)pour lâinitialiser et le mettre Ã  jour de la sorte :âAvec cette base, on peut remplacer une partie des Observables, mais il y a toujours une notion RxJs utile, Ã  savoir le highOrderMapping (mergeMap, switchMap,â¦). Pour cela, il existe la mÃ©thode computed. Elle permet de crÃ©er un Signal en le combinant avec dâautres :Gardez en tÃªte que cette combinaison est assez primaire et permet de couvrir des cas simples.âQuand utiliser un Observable ?Il est tentant de laisser tomber les Observable pour quelque chose de plus lisible et rÃ©cent. Cependant, ils sont moins puissants que des Observables car moins flexibles de par lâabsence de RxJs. MÃªme si cette librairie est souvent la cause de beaucoup de bugs si elle est mal utilisÃ©e, elle nâen reste pas moins trÃ¨s complÃ¨te pour rÃ©pondre Ã  presque tous les besoins.Le principal avantage comparÃ© aux Signals est le chaÃ®nage de pipe pour crÃ©er des Observables complexe (combineLatest, forkJoin, withLatestFrom,â¦), de pouvoir gÃ©rer du cache ou encore rejouer de la donnÃ©e.Comment faisons nous la conversion ?Maintenant que vous avez compris quâil ne faudra pas convertir totalement votre application, je vais vous montrer comment passer des Observables aux Signals de faÃ§on simple.Changer le type de votre ObservableLa premiÃ¨re Ã©tape pour commencer Ã  nettoyer votre code peut Ãªtre de simplement changer le type de vos Observables avec lâopÃ©rateur toSignal :ââ ï¸ Le toSignal dÃ©clenche directement lâabonnement de lâObservable dont il dÃ©pend. La premiÃ¨re valeur peut Ãªtre undefined si on ne fait pas attention Ã  ce point ! Câest pour cela quâon peut prÃ©ciser grÃ¢ce Ã  initialValue la premiÃ¨re valeur (comme un BehaviourSubject en quelque sorte)âAbandonner les @InputAdmettons que vous avez dans votre composant un @Input et que vous voulez afficher ses propriÃ©tÃ©s :âââLier vos mises Ã  jour de donnÃ©es Ã  lâinputReprenons lâexemple dâavant oÃ¹, Ã  chaque changement de lâinput, je veux savoir si le PokÃ©mon est capturÃ©. Et si je le capture, je veux mettre Ã  jour cette donnÃ©e : ââA la base, on avait une variable boolean mise Ã  jour grÃ¢ce Ã  lâObservable, maintenant on travaille directement avec le Signal.Abandonner les @OutputSi vous souhaitez cascader une valeur de lâenfant au parent, vous pouvez utiliser lâOutput. Le problÃ¨me, câest que lâimplÃ©mentation est trÃ¨s verbeuse. Angular 17 dÃ©barque avec un nouveau type dâoutput, le model.âââSimplifiez le Two Way BindingAvec lâexemple dâavant vous nâÃªtes pas convaincu de la plus-value et je comprends, car la taille est sensiblement la mÃªme. Mais quâen est-il si vous souhaitez cascader une valeur du parent Ã  lâenfant de lâenfant au parent ? Et bien le code sera EXACTEMENT le mÃªme et lÃ , Ã§a devient intÃ©ressant ! ââChanger un store PlainRxJs (Subject / Observable)Les Signals peuvent Ãªtre comparÃ©s Ã  des Subjects car on peut les modifier. Ils ont cependant plus de souplesse, car on Ã©crase la valeur dâun Subject avec .next() et on la met Ã  jour dans un Signal avec .set() ou .update(). De plus, il est possible dâexposer des Signals en lecture seule pour les protÃ©ger. Sachant Ã§a, la conversion est assez triviale :âââVous me direz quâil nây a pas beaucoup de diffÃ©rence Ã  part lâannotation. Mais encore une fois, il est plus simple dâafficher directement la valeur dâun Signal que celle dâun Observable car elle ne nÃ©cessite pas de variable intermÃ©diaire.Je ne sais pas gÃ©rer la mise Ã  jour dâune liste avec les Subject !Pour ceux ayant maniÃ© les Subjects, vous savez quâil est trÃ¨s compliquÃ© de manier une liste, car encore une fois, on Ã©crase la valeur ! On pourrait passer par une Array classique, mais on perd lâaspect rÃ©actif. Il est donc difficile de simplement la complÃ©ter. GrÃ¢ce aux Signals, câest maintenant possible : ââConclusionMaintenant, vous avez toutes les billes en main pour migrer une partie de vos Observable vers les Signal. Terminons par une synthÃ¨se :ObservableSi vous souhaitez mettre de la logique asynchrone complexe avec de multiples Ã©vÃ©nements, composition et transformations de donnÃ©es, les opÃ©rateurs RxJs vous permettront de faire presque tout ;Si votre architecture est Ã©vÃ©nementielle oÃ¹ diffÃ©rentes parties de votre application doivent rÃ©agir Ã  des Ã©vÃ©nements et propager des changements. RxJs fournit des outils puissants pour gÃ©rer les flux d'Ã©vÃ©nements et les dÃ©pendances d'Ã©vÃ©nements ;SignalSi vous souhaitez gÃ©rer des Ã©vÃ©nements simples sans logique combinatoire poussÃ©e ;Certaines nouvelles librairies Ã©tant basÃ©es sur les Signal comme SignalStory, il est plus logique de travailler avec pour ne pas introduire une librairie externe comme RxJs ;DocumentationLewis Cianti - Angular signals vs.Â observables : How and when to use eachAngularTahitoa Merlin - Angular Signal modelSignalstoryâCopyright Â©2023 TheodoÂ FinTech. Tous droits rÃ©servÃ©s.EquipeNous rejoindreContactTheodoPolitique de confidentialitÃ©Mentions lÃ©gales