Infrastructure d'une web app avec AWS Lambda, API Gateway & DynamoDB grÃ¢ce Ã  Terraform
 Â Sipios devient TheodoÂ FinTech, lâentitÃ© experte Services Financiers du groupe Theodo 
ClientsOffresMobile Wealth ManagementFintechÂ Due DiligenceMVPÂ at scaleConception et design UX/UIProgramme d'APIsationFinTech as a serviceExpertisesReactJSOpen BankingSpring BootKotlinBlog

Tech

BusinessCarriÃ¨re

Equipe


Nous rejoindreContactInfrastructure d'une web app avec AWS Lambda, API Gateway & DynamoDB grÃ¢ce Ã  Terraform6 minutesMis Ã  jour le25/3/2024Share this postDÃ©ployez votre application serverless, scalable et rÃ©siliente dans le cloud.#Cloud#Serverless#AWS Amazon#APIMaxime DescoutsSoftware Engineer1. IntroductionLors de la conception dâune application web, opter pour une architecture Cloud Native est une maniÃ¨re simple pour obtenir une application scalable, hautement disponible et rÃ©duire les coÃ»ts de son infrastructure.Imaginez avoir une application de liste de courses hÃ©bergÃ©e sur un service cloud, avec une API, une base de donnÃ©e, mais dont lâinfrastructure ne coÃ»te rien !Dans cet article, nous allons suivre les Ã©tapes permettant de crÃ©er de bout en bout lâapplication Cloud Native suivante, basÃ©e sur le cloud AWS :Cloud Native WebappNous allons voir les fondamentaux pour crÃ©er une architecture Cloud Native et comment automatiser la crÃ©ation des ressources de notre infrastructure avec Terraform.Dans chaque section, des extraits de code Terraform seront fournit afin de vous guider dans la crÃ©ation de lâapplication.Voici lâarchitecture cible que nous allons construire progressivement :SchÃ©ma de lâinfrastructure finaleâTerraform : Outil dâInfrastructure as Code (IaC) pour dÃ©finir et provisionner les ressources de l'infrastructure.API Gateway : Service AWS pour crÃ©er, publier, maintenir, surveiller et sÃ©curiser les API.Lambda : Service pour exÃ©cuter du code sans provisionnement ni gestion de serveurs (serverless).DynamoDB : Service de base de donnÃ©es NoSQL dâAWS qui simplifie la gestion de scalabilitÃ© et la rÃ©silience de la base de donnÃ©e.S3 Bucket : Simple Storage Service, un service de stockage de data. Dans notre architecture, nous avons un bucket contenant le code source de la fonction Lambda, et un autre bucket contenant le code source de notre application web.Cloudfront Distribution : Content Delivery Network (CDN) d'AWS pour distribuer des applications et des API Ã  des utilisateurs du monde entier avec une latence faible.Tous les fichiers Terraform utilisÃ©s pour crÃ©er notre webapp, incluant les fichiers HTML et JS, sont disponible sur repository GitHub suivant : https://github.com/mdesc/cloud-native-webappNâoubliez pas dâexÃ©cuter la commande suivante dans le directory aprÃ¨s avoir clone le projet : terraform initArchitecture Cloud-Native ?Le Cloud-Native est une approche du dÃ©veloppement et du dÃ©ploiement d'applications qui se basent sur le cloud, faisant le plus souvent usage de microservices, de conteneurisation, d'automatisation et de serverless. Ces pratiques permettent aux applications de bÃ©nÃ©ficier d'une meilleure rÃ©silience, dâune mise Ã  lâÃ©chelle simplifiÃ©e et de rÃ©duire les coÃ»ts liÃ©s Ã  la maintenance des machines faisant tourner lâinfrastructure.âð¡ Avantages dâune architecture Cloud-Native :- ScalabilitÃ© : Avec la capacitÃ© Ã  ajuster dynamiquement les ressources en fonction de la demande, les applications cloud-native peuvent gÃ©rer efficacement les fluctuations du nombre dâutilisateurs et les pics de charges.- Cost Management : Les architectures cloud-native permettent de ne payer que pour les ressources consommÃ©es, minimisant le gaspillage et optimisant les coÃ»ts.âConcrÃ¨tement, dans le cadre de cet article, notre application de liste de courses utilise une architecture serverless, ce qui signifie que l'infrastructure sous-jacente est entiÃ¨rement gÃ©rÃ©e par le fournisseur de services cloud, ici AWS.Cela comprend la gestion des serveurs, des ressources de stockage et de la mise en rÃ©seau.Nous nâavons donc pas Ã  payer pour des ressources inutilisÃ©es ou Ã  gÃ©rer la mise Ã  l'Ã©chelle : les ressources nÃ©cessaires seront automatiquement allouÃ©es lorsque l'application sera sollicitÃ©e.Pourquoi Terraform ?Terraform est un outil d'Infrastructure as Code (IaC) qui vous permet de dÃ©finir et de provisionner une infrastructure en utilisant un langage dÃ©claratif.Dans une approche dÃ©clarative, vous dÃ©finissez l'Ã©tat dÃ©sirÃ© de votre infrastructure, et Terraform gÃ¨re l'orchestration pour atteindre cet Ã©tat. Cela contraste avec les outils IaC impÃ©ratifs, comme Ansible, oÃ¹ vous devez spÃ©cifier les Ã©tapes pour atteindre un Ã©tat dÃ©sirÃ© en configurant les ressources.La nature dÃ©clarative de Terraform permet de se concentrer sur le rÃ©sultat final plutÃ´t que sur les dÃ©tails procÃ©duraux. Cela simplifie la gestion de l'infrastructure : il est plus simple de gÃ©rer les diffÃ©rentes versions de son infrastructure, faire des rollbacks etc.âð¡ Configurer votre environnement local :Voici un lien dÃ©taillant la dÃ©marche Ã  suivre pour installer Terraform et le configurer avec la CLI AWS : https://developer.hashicorp.com/terraform/tutorials/aws-get-started/aws-buildâLe but de cet article nâÃ©tant pas dâexpliquer le fonctionnement de Terraform, voici quelques explications rudimentaires : https://developer.hashicorp.com/terraform/tutorials/aws-get-started/infrastructure-as-codeâ2. CrÃ©ation dâun site statiquePour obtenir rapidement un premier exemple de notre future webaapp, nous allons commencer par crÃ©er les ressources nous permettant dâavoir un simple site web statique.Nous allons dans un premier temps hÃ©berger notre application statique via un Bucket S3, qui sera exposÃ© par un CloudFront (CDN), et donc accessible via une url cloudfront.net.ConcrÃ¨tement, voici un schÃ©ma reprÃ©sentant lâarchitecture de notre webapp Ã  la fin de cette premiÃ¨re section :âStatic webapp Infrastructureâ2.1 Stocker des fichiers dans S3CommenÃ§ons par crÃ©er un Bucket S3 afin dây stocker les fichiers statiques de notre site.S3 peut Ãªtre comparÃ© Ã  un Google Drive, mais pour application : nous allons rendre disponible des fichiers qui seront utilisÃ© par les futures ressources de notre architecture.Voici le code Ã  mettre dans votre fichier main.tf :âVous pouvez ensuite exÃ©cuter la commande suivante pour crÃ©er les ressources dÃ©crites par le fichier main.tf :terraform apply --auto-approveâNous nous attendions bien Ã  avoir 2 ressources : un nom alÃ©atoire pour notre bucket, (random_pet), et un bucket S3 (aws_s3_bucket).ââ ï¸ Nâoubliez pas dâexÃ©cuter un terraform destroy --auto-approve Ã  chaque fois que vous avez finit de travailler sur votre infra, pour ne pas laisser des ressources tourner inutilement dans AWS, bien que lâensemble des ressources de cet article soient dans le free tier : https://aws.amazon.com/free.*âMaintenant, nous pouvons crÃ©er des ressources permettant de gÃ©rer la visibilitÃ© du bucket, et y upload notre fichier HTML :2.2 Configurer le Content Delivery Network (CDN)IntÃ©grer CloudFront Ã  notre architecture permet dâassurer que notre application est accessible rapidement partout dans le monde, et Ã©galement nous Ã©vitons de communiquer le lien direct vers notre bucket, exposÃ© Ã  tout internetâ¦Pour cela, crÃ©ons une distribution CloudFront avec les permissions nÃ©cessaires pour accÃ©der au fichier index.html afin de lâexposer via une URL âcloudfront.netâ :â3. Ajout des fonctionnalitÃ©s dynamiquesPour passer dâun site web statique Ã  dynamique, nous allons ajouter une base de donnÃ©e (DynamoDB), du code JS (exÃ©cutÃ© via une Lambda function) et une API Gateway.3.1 CrÃ©ation dâune table DynamoDB:DynamoDB est la base de donnÃ©e NoSQL scalable de AWS. Contrairement aux bases de donnÃ©es relationnelles, DynamoDB e requiert pas de schÃ©ma fixe.Cela rend DynamoDB idÃ©al pour les applications web oÃ¹ les besoins en donnÃ©es peuvent Ã©voluer rapidement.3.2 ImplÃ©mentation dâune Lambda Function:Nous allons utiliser une fonction Lambda pour interagir avec la table DynamoDB, voici une introduction au service Lambda de AWS : https://docs.aws.amazon.com/lambda/latest/dg/welcome.htmlDans notre cas, nous devons upload un fichier lambda.js sur un bucket S3 pour ensuite crÃ©er la ressource Lambda, qui exÃ©cutera le code JS :âLe code contenu dans lambda.js va Ã©crire ou lire dans la DB en fonction de lâÃ©vÃ¨nement que la lambda reÃ§oit en input. Libre Ã  vous dây ajouter des fonctionnalitÃ©s ou de les sÃ©parer dans plusieurs lambdas pour amÃ©liorer lâarchitecture !De plus, nous devons accorder Ã  notre lambda certaines permissions pour quâelle puisse interagir avec la table DynamoDB. Il suffit les dÃ©finir via les fichiers policy.json Â et asssume_role_policy.json :ââ ï¸ Nâoubliez pas de remplacer <your-account-id> par lâid de votre compte AWS.ââNous utilisons ces 2 fichiers JSON pour crÃ©er les ressources aws_iam_role et aws_iam_role_policy de notre lambda Â :ââNous pouvons maintenant crÃ©er un fichier ZIP contenant le code source JS de notre lambda puis lâuploader sur le bucket S3 afin de crÃ©er la ressource Lambda dans AWS :âSi vous Ãªtes attentif, vous avez remarquÃ© la prÃ©sence de permissions liÃ©e Ã  des âlogsâ dans le fichier de policy de la Lambda.Cela octroie Ã  la lambda les autorisations requises pour crÃ©er des fichiers de logs dans une ressource CloudWatch, trÃ¨s utiles pour dÃ©bugger notre code ou monitorer la lambda.ââÃ cette Ã©tape, notre lambda peut lire et Ã©crire dans la table myDB de DynamoDB.NâhÃ©sitez pas Ã  tester cette interaction depuis la CLI AWS ou directement sur le dashboard AWS pour mieux comprendre son fonctionnement.Commande pour invoke une lambda depuis la CLI : Â aws lambda invoke --function-name <nom_de_la_fonction>Ãvidemment, nous ne voulons pas appeler notre lambda directement depuis notre future webapp. Il manque une couche essentielle Ã  notre architecture : une API Gateway.3.3 CrÃ©ation de lâAPI Gateway & IntÃ©gration Ã  la Lambda:L'API Gateway est le point d'entrÃ©e pour notre webapp et agit comme une passerelle pour toutes les requÃªtes entrantes.Le but est dâarriver Ã  cette architecture :âBackend Infrastructure of the webappâCette ressource fonctionne en associant des routes HTTP Ã  des actions spÃ©cifiques, telles que l'appel de fonctions AWS Lambda (Ã§a nous intÃ©resses !).Lorsqu'une requÃªte est reÃ§ue sur une route spÃ©cifique, l'API Gateway la transmet Ã  la fonction Lambda appropriÃ©e, qui peut ensuite traiter la demande et renvoyer une rÃ©ponse.Cette intÃ©gration permet une exÃ©cution de code serverless, basÃ©e sur des Ã©vÃ©nements dÃ©clencheurs, depuis notre HTML :ââUne fois cette ressource crÃ©Ã©e, nous ajoutons l'URL de l'API Gateway, pour crÃ©er le index.html, via un script local (sed "s|BACKENDURL|$( cat ./site.env )|" ./site/template.html > ./site/index.html) qui lit lâURL Ã©crite dynamiquement dans un fichier site.env en local suite Ã  la crÃ©ation de lâAPI Gateway :ââIl faut Ã©galement ajouter cette ressource en dÃ©pendance Ã  celle qui upload le fichier index.html, pour ne pas risquer de lâupload avant que lâURL de lâAPI Gateway nây soit Ã©crite :dans la ressource null_resource.upload_to_s3, ajoutez null_resource.build dans la liste Â depends_on.Nous pouvons maintenant tester l'intÃ©gration entre l'API Gateway et la Lambda. Pour ce faire, lancez Chrome sans vÃ©rifier les CORS dans un premier temps (avec le flag --disable-web-security), ce qui nous permettra de voir si les requÃªtes sont traitÃ©es correctement sans restriction de politique CORS.Conclusion :Vous avez maintenant une webapp pour gÃ©rer votre liste de courses avec des fonctionnalitÃ©s simples, dÃ©ployable sur le cloud AWS Ã  tout moment !En plus dâÃªtre hÃ©bergÃ© par un cloud provider, notre infrastructure se basera sur plusieurs couches qui seront rÃ©silientes aux pannes, et qui seront mises Ã  lâÃ©chelle automatiquement : nous nâavons rien Ã  gÃ©rer, tout est dÃ©lÃ©guÃ©.Lâinfrastructure mise en place durant cet article nâest Ã©videmment pas parfaite et est simplifiÃ©e par soucis de simplicitÃ©, nÃ©anmoins voici quelques next-steps pour amÃ©liorer lâinfrastructure :Ajouter une couche pour gÃ©rer lâauthentification des utilisateurs sur notre app (avec le service Cognito de AWS)Configurer plus prÃ©cisÃ©ment la visibilitÃ©s et lâaccÃ¨s de nos ressources : par exemple, ne pas mettre les buckets en publicGÃ©rer les CORS avec lâintÃ©gration API Gateway - Lambda pour ne pas avoir Ã  lancer Chrome en dÃ©sactivant la vÃ©rification des CORSâCopyright Â©2023 TheodoÂ FinTech. Tous droits rÃ©servÃ©s.EquipeNous rejoindreContactTheodoPolitique de confidentialitÃ©Mentions lÃ©gales