A Step-by-Step Guide to Implement JWT Authentication in NestJS using Passport
 Â Sipios devient TheodoÂ FinTech, lâentitÃ© experte Services Financiers du groupe Theodo 
ClientsOffresMobile Wealth ManagementFintechÂ Due DiligenceMVPÂ at scaleConception et design UX/UIProgramme d'APIsationFinTech as a serviceExpertisesReactJSOpen BankingSpring BootKotlinBlog

Tech

BusinessCarriÃ¨re

Equipe


Nous rejoindreContactA Step-by-Step Guide to Implement JWT Authentication in NestJS using Passport10 minutesMis Ã  jour le18/1/2024Share this postImplement a secure, easily extensible, and simple authentication system in a NestJS project using Passport middleware.#NestJS#Security#BackendCamille FauchierSoftware EngineerIntroductionIn the domain of computer security, authentication and authorization are fundamental processes. Authentication, the initial step, validates a user's identity through methods like passwords or biometrics. Once authenticated, authorization comes into play, determining the user's permissions and access rights. It's crucial to note that authentication precedes authorization, establishing the user's identity before enforcing access control measures.The purpose of this article is to provide a step-by-step guide for implementing authentication system in a NestJS project using the Passport middleware module.Our authentication system will embody the key attributes of an exemplary system: it will be secure, easily extensible, and simple, as every good authentication system should be.If you want to look at the full code you can check out my repo on Github.Dependencies installationpassport (^0.7.0) is an authentication middleware for Node.js, widely used and extensible.passport-local ( ^1.0.0) is a Passport strategy for authentication with an email and password.passport-jwt (^4.0.1)is a Passport strategy for authentication with a JSON Web Token (JWT).@nestjs/passport (^10.0.3) is a Passport integration for NestJS.@nestjs/jwt (^10.2.0) is used to handle JWT tokens in NestJS. JWT (JSON Web Tokens) is a compact and safe way to transmit information between parties as a JSON object. this information can be verified and trusted because it is digitally signed.bcrypt (5.1.1)is a library for hashing passwords.âââ Why you should use Passport Module to implement your authentication service For implementing authentication in your NestJs App I highly recommend relying on the Passport module. It enhances security through its robust strategies like JWT and OAuth, aligning with industry best practices. Among other things, it supports a plug-and-play architecture, enabling the addition of new authentication methods or the replacement of existing ones without major code modifications. This means you can effortlessly integrate custom authentication strategies, ensuring scalability and adaptability for your app's future needs. In other words, Passport ensures a smooth developer experience, making it easy for you to understand and implement authentication mechanisms.User ModuleDefine a model (e.g., a class or an interface) for your users, including necessary fields such as email, password, etc. The user service responsible for all interactions with the database regarding users includes methods to create, find, update, and delete users. However, notice that the signup method must be handled by the authentication service.Authentication ModuleYour authentication module should be (at least) responsible for the following crucial tasks:User Identity verificationPassword Hashing and StorageToken Generation and ValidationAuthentication ServiceCreate an AuthService service that will inject necessary services, such as UsersService for interacting with the user database and JwtService for handling JWT tokens.AuthService Methods:validateUser: Takes a username and password as input and checks if the user exists and if the password is correct.login: Takes user data as input and generates a JWT tokenregister: Checks if a user with the provided email already exists. If a user with the provided email already exists, throws a BadRequestException, if not, hash and salt the user's password using bcrypt, store the new user in the database and log the user in.âââ Why is hashing and salting passwords mandatory? A salt is simply a random data used as an additional input to the hashing function to safeguard your password. The random string from the salt makes the hash unpredictable.A password hash involves converting the password into an alphanumeric string using specialized algorithms.Hashing and salting are irreversible and ensure that even if someone gains access to the hashed passwords, they will not be able to decrypt them to recover the original passwords.Hystorically bcrypt is recognized as the best hashing algorithm. However, in terms of robustness against all the new cryptographic attacks targeting hashing algorithms, the current clear winner is argon2. However, since the âyouth" (2015) of this algorithm, I chose to use bcryptâPassport ConfigurationCreate a Local Strategy for authentication with username and password.You need to create a LocalStrategy that extends PassportStrategy.This authentication method is primarily used for authenticating users based on local credentials such as usernames and passwords. By default the strategy looks for a username field, in the code below we override usernameField to look for an email field since we want to login with an email.validate method : Requires the server to check the provided username and password against the authentication service.âCreate a JWT Strategy to validate JWT tokensThe JwtStrategy validates the token sent by the user. It extracts the user ID from the token and looks it up in the database.This authentication method is used for authenticating users based on the presence and validity of a JSON Web Token (JWT). It extracts the user ID from the token and looks it up in the database.validate method: Involves checking the digital signature of the JWT to ensure its integrity and validating claims to determine the user's identity and permissions. The validate method receives the decoded data from the JWT token and returns user data if the token is valid. You can add additional logic, e.g., to fetch additional user information from the database.âAuthentication ControllerCreate endpoints for signup (register) and login (login) that both return JWT tokens. For the login endpoint, the @UseGuards decorator is applied to the login method, indicating that the AuthGuard named 'local' should be used, that will trigger the LocalStrategy previously implemented.ââ Passing the Access Token to the clientâIn this tutorial we pass the access token to the client in the response body for simplicity reasons, but it can also be done with a cookie. Since cookies are automatically included in every HTTP request, it simplifies the process of including the access token without explicit action from the client.You can read this article Cookie-Based Authentication vs Token-Based Authentication to choose the most adapted method to your case.âAuthentication Module ConfigurationYour AuthModule should import the JwtModule to handle JSON Web Token (JWT) generation and verification.The registerAsync method allows for asynchronous configuration, facilitating the use of the ConfigService to retrieve the JWT secret from environment variables stored in a .env file.Storing sensitive configurations in a .env file as environment variables is preferred because it enhances security and avoids accidental exposure in version control systems (â ï¸ donât forget to add it in the .gitignore ). This practice facilitates easy configuration management across different environments while preserving confidentiality and minimizing the risk of inadvertent information disclosure.âRoutes security: implementing a whitelisting strategyââ Why should you use a whitelisting strategy ? To ensure the security of your app, the best practice is to choose a whitelisting strategy. Whitelisting, involves explicitly allowing only approved elements or actions, providing precise control over permissions in a system. It is considered a better practice than blacklisting as it reduces the attack surface by permitting only known and necessary entities but also minimizes developers' errors resulting from oversights or thoughtlessness.âIn our context, to implement whitelisting you basically just have to create a guard for JWT-based authentication, and a decorator to designate public routes exempt from JWT authentication. This strategy offers a granular and flexible approach to securing specific endpoints.Create a guard and a decoratorFirst, create the following decorator:âThen you can add the following JwtGuard class:Class constructor: takes a single parameter - an instance of the Reflector class. The Reflector class is part of the core NestJS library and is used to retrieve metadata associated with classes, methods, and their decorators.canActivate Method:The canActivate method is a crucial part of the JwtGuard class. It is invoked during the request lifecycle to determine whether the current request should be allowed or denied based on the provided JWT.The first step is to check if the route or endpoint is marked as public using the @Public decorator previously created.The Reflector is used to retrieve metadata labeled as 'isPublic' from the handler and class associated with the current execution context.If the route is marked as public, the method returns true, indicating that no further authentication checks are needed.If the route is not marked as public, the super.canActivate(context) call invokes the corresponding method in the parent class (AuthGuard). This method performs the actual JWT validation and authentication checks.Configure the AppModuleWithin the providers array, the provider for the JWT guard is registered using the APP_GUARD token. This provider specifies the use of the JwtGuard class as the global guard for the entire application.âNow if the routes are not marked with @Public(), every incoming request undergoes JWT authentication.For example, in the GET endpoint below, the global guard validates and decodes the JWT access token and attaches the user information to the request object, making it accessible in the controller methods.âSpecify public routesYou have now the option to apply the @Public() decorator to methods or classes that don't require JWT authentication. In our scenario, we apply this decorator to the AuthController.âCreate custom decoratorsIn order to make your code more readable and transparent, you can create your own custom decorator and reuse it across all of your controllers. Itâs a very good practice to avoid code duplication.Depending on the specific requirements of your project, (e.g. Â Role-based access control), you can create numerous and various decorators and guards to address diverse authorization scenarios. For this article we will only create a Â @User() decorator that extracts the user information from the request object in the NestJS execution context.âThen you just have to pass it to your controller to retrieve the user information encapsulated in your request.âConclusionDependancy graph of the authentication systemâIn conclusion, crafting a secure and efficient authentication system in a NestJS application is a meticulous but easy process. Â We have integrated Passport to handle various authentication strategies, used JWT tokens to enhance security, and the global guards to ensure consistent authentication across the entire project. Â By prioritizing security, simplicity, and extensibility in our implementation, we have established a foundation that not only safeguards user data but also allows for seamless integration of future features.By following this step-by-step guide, you can establish a robust authentication system in your NestJS applications, promoting secure user interactions and data protection. The provided code snippets serve as a foundation for building upon and adapting to specific project requirements (Role-based access control, OAuth).However, I did not get into refresh token even though they are an essential component of secure authentication systems, particularly in scenarios where long-lived sessions are required. A deep dive into implementing refresh tokens in a NestJS context could be valuable for you if you aim to build robust and secure authentication systems.SourcesDocumentation NestJsAdding Salt to Hashing: A Better Way to Store PasswordsâCopyright Â©2023 TheodoÂ FinTech. Tous droits rÃ©servÃ©s.EquipeNous rejoindreContactTheodoPolitique de confidentialitÃ©Mentions lÃ©gales