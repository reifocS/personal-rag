From Zero to Hero : La Magie des tests end-to-end avec Playwright !
 Â Sipios devient TheodoÂ FinTech, lâentitÃ© experte Services Financiers du groupe Theodo 
ClientsOffresMobile Wealth ManagementFintechÂ Due DiligenceMVPÂ at scaleConception et design UX/UIProgramme d'APIsationFinTech as a serviceExpertisesReactJSOpen BankingSpring BootKotlinBlog

Tech

BusinessCarriÃ¨re

Equipe


Nous rejoindreContactFrom Zero to Hero : La Magie des tests end-to-end avec Playwright !7 minutesMis Ã  jour le25/1/2024Share this postPlongeons tÃªte la premiÃ¨re dans l'univers des tests de bout en bout pour une application web ! Nous verrons comment Ã©crire des tests avec Playwright et esquiver les piÃ¨ges. Suivez le guide ! ð#End to end testing#Typescript#Software Quality Testing#Front-endQuentin GrauSoftware EngineerâNous allons dâabord planter le dÃ©cor avec une petite mise en situation qui vous permettra de mieux comprendre pourquoi Ã©crire des tests end-to-end. Si vous voulez passer directement Ã  la pratique, vous pouvez scroller directement jusqu'au paragraphe suivant.Introduction et contexteDisons que vous Ãªtes un dÃ©veloppeur ou une dÃ©veloppeuse en train de travailler sur une application web rÃ©volutionnaire de To-do List.Vous codez votre premiÃ¨re fonctionnalitÃ© qui permet de crÃ©er des To-dos, vous la testez en local, elle fonctionne bien, vous la dÃ©ployez sur le serveur qui hÃ©berge votre appli.Votre application rencontre un grand succÃ¨s et des milliers dâutilisateurs la visitent tous les jours !Vous nâavez pas envie de les dÃ©cevoir et dÃ©cidez de coder une deuxiÃ¨me fonctionnalitÃ© permettant de modifier les To-dos, vous la testez en local, elle fonctionne bien, donc vous la dÃ©ployez sur le serveur.Mais lÃ , catastrophe ! Le nombre dâutilisateurs baisse considÃ©rablement de jour en jour. Vous regardez les avis et vous vous rendez compte quâils se plaignent de ne plus pouvoir crÃ©er de To-dos.En effet, lors du dÃ©ploiement de la deuxiÃ¨me fonctionnalitÃ©, vous avez cassÃ© la premiÃ¨re fonctionnalitÃ©, vous avez introduit une rÃ©gression.Vous choisissez d'intÃ©grer une troisiÃ¨me fonctionnalitÃ© pour supprimer les To-dos. AprÃ¨s avoir codÃ© cette nouvelle fonctionnalitÃ©, vous effectuez des tests manuels sur les trois fonctionnalitÃ©s existantes pour ne pas introduire de rÃ©gression. Une fois confirmÃ© que tout fonctionne correctement, vous dÃ©ployez votre code.Le temps passe et les fonctionnalitÃ©s sâadditionnent, vous prenez un temps fou Ã  tester Ã  la main toutes les anciennes fonctionnalitÃ©s avant dâen introduire une nouvelle. Il vous arrive de temps en temps de passer Ã  cÃ´tÃ© de rÃ©gressions car vous nâavez pas le temps de tester tous les cas.Il est temps dâautomatiser tout Ã§a ! Ajoutons des tests end-to-end (ou de bout en bout) Ã  votre application afin de pouvoir tester rapidement tous les parcours critiques de votre appli. En plus, cela vous permettra dâajouter des nouvelles fonctionnalitÃ©s sans avoir peur de casser les fonctionnalitÃ©s existantes !Tout dâabord que sont les tests âend-to-endâ ?Les tests end-to-end (ou de bout en bout) sont des tests qui simulent les actions de l'utilisateur sur l'interface utilisateur. Ils sont trÃ¨s simples Ã  Ã©crire et permettent de gagner du temps car ils vous Ã©vitent de tester votre app manuellement.Les tests end-to-end se situent en haut de la pyramide de tests et reprÃ©sentent les tests les plus rÃ©alistes. Cependant, ils sont aussi les plus lents Ã  exÃ©cuter et nÃ©cessitent un environnement complet, cela peut demander plus de ressources et Ãªtre plus coÃ»teux.Dans le cas de lâapplication de To-do list, il faudrait tester la crÃ©ation dâune To-do. Le test doit alors :naviguer vers lâURL de lâapplicationcliquer sur le bouton âCrÃ©er une To-doâsaisir un nom pour votre To-docliquer sur le bouton âValiderâ.Ensuite, le test affirme (assert en anglais) quâune checkbox portant le nom de la To-do est visible Ã  lâÃ©cran.Passons Ã  la pratique !Comme exemple dâapplication, nous utiliserons une application simple de To-do, dÃ©jÃ  codÃ©e.Vous trouverez son dÃ©pÃ´t Github ci-dessous :Repo Github: https://github.com/MatheusCavini/ReactJS-ToDoList.gitVous pouvez nÃ©anmoins utiliser nâimporte quelle autre application, comme la vÃ´tre par exemple.Clonez le dÃ©pÃ´t avec git clone https://github.com/MatheusCavini/ReactJS-ToDoList.git, naviguez dans le dossier crÃ©Ã© avec cd ReactJS-ToDoList, installez les dÃ©pendances avec npm i, puis lancez lâapp avec npm start et enfin testez quelques fonctionnalitÃ©s manuellement si vous le souhaitez.Vous devriez arriver sur une page qui ressemble Ã  Ã§a :Installons Playwright sur votre machine !Nous aurons besoin dâinstaller Playwright. En effet, câest la librairie de tests que nous utiliserons pour Ã©crire nos tests end-to-end.ExÃ©cutez cette commande Ã  la racine du projet afin dây installer Playwright.On vous demandera sÃ»rement dans quel dossier vous voulez voir apparaÃ®tre vos tests, je vous conseille de laisser lâoption par dÃ©faut âtestsâ :On vous demandera Ã©galement si vous souhaitez ajouter un workflow Github Actions, rÃ©pondez non (N).Cependant, on a bien envie dâinstaller les navigateurs Playwright qui nous permettront de lancer les tests end-to-end sur lâapplication (Y).Des fichiers ont Ã©tÃ© crÃ©Ã©s aprÃ¨s lâexÃ©cution de la commande :- Le premier fichier est un fichier de configuration, vous le modifierez si vous avez besoin de configurations avancÃ©es de Playwright telles que lâexÃ©cution de tests en parallÃ¨le, la personnalisation du rapport de tests, etcâ¦- Les deux autres fichiers sont des fichiers dâexemples de Playwright, vous pouvez les supprimer car nous allons Ã©crire nos tests de zÃ©ro !Comprenons comment Playwright fonctionneLes tests Playwright suivent un schÃ©ma simple :RÃ©cupÃ©rer des Ã©lÃ©ments : GrÃ¢ce Ã  diffÃ©rents localisateurs.âExÃ©cuter des actions : Interagissez avec les Ã©lÃ©ments et naviguez dans votre application.âAffirmer l'Ã©tat : Comparer l'Ã©tat actuel aux rÃ©sultats attendus.LocalisateursPlaywright utilise des localisateurs (locators en anglais) afin de rÃ©cupÃ©rer des Ã©lÃ©ments de la page. Il est possible de rÃ©cupÃ©rer un Ã©lÃ©ment de diffÃ©rentes maniÃ¨res et plutÃ´t que dâutiliser la fonction page.locator() ou page.$() en lui passant un sÃ©lecteur du DOM, il est prÃ©fÃ©rable dâutiliser les fonctions prÃ©dÃ©finies de Playwright :page.getByRole() pour rÃ©cupÃ©rer un Ã©lÃ©ment par des attributs dâaccessibilitÃ© explicites ou implicites (button, checkbox, dialog, â¦)page.getByText() pour rÃ©cupÃ©rer un Ã©lÃ©ment par du textepage.getByLabel() pour rÃ©cupÃ©rer un Ã©lÃ©ment de formulaire par son label associÃ©page.getByPlaceholder() pour rÃ©cupÃ©rer un champ de saisie par son placeholderpage.getByAltText() pour rÃ©cupÃ©rer un Ã©lÃ©ment, souvent une image, par son alternative textuellepage.getByTitle() pour rÃ©cupÃ©rer un Ã©lÃ©ment par son attribut titlepage.getByTestId() pour rÃ©cupÃ©rer un Ã©lÃ©ment par son attribut data-testidPar exemple, pour rÃ©cupÃ©rer le bouton qui contient le label âValiderâ :âð¡Bonne pratique : donner la prioritÃ© aux localisateurs visibles par l'utilisateur, tels que le texte ou le rÃ´le dâaccessibilitÃ©, plutÃ´t que d'utiliser des sÃ©lecteurs JQuery qui sont liÃ©s Ã  l'implÃ©mentation et risquent de se briser en cas de modification de la page.âActionsAprÃ¨s avoir rÃ©cupÃ©rÃ© un Ã©lÃ©ment, on peut exÃ©cuter des actions dessus avec les fonctions de Playwright. Les actions recommandÃ©es sont :locator.fill() pour remplir un champ textelocator.check() pour cocher une case Ã  cocherlocator.selectOption() pour sÃ©lectionner une option dans une liste dÃ©roulante, par exemplelocator.click() pour cliquer, tout simplement, sur un bouton, par exemplelocator.press() pour simuler lâappui sur une touche par un utilisateur, la touche âEntrÃ©eâ, par exemplelocator.setInputFiles() pour dÃ©poser des fichierslocator.focus() pour focaliser un Ã©lÃ©mentlocator.dragTo(locator) pour glisser-dÃ©poser un Ã©lÃ©ment Ã  un autre Ã©lÃ©mentSi on veut remplir un champ avec le texte âHelloâ, on fera :âSi on veut cocher une case Ã  cocher, on fera :âSi on veut sÃ©lectionner une option dans une liste dÃ©roulante, on fera :âAffirmationsIl existe de nombreuses affirmations pour diffÃ©rentes conditions :expect(locator).toBeChecked() permet dâaffirmer quâune case est cochÃ©eexpect(locator).toBeEnabled() permet dâaffirmer quâun Ã©lÃ©ment est activÃ©expect(locator).toBeVisible() permet dâaffirmer quâun Ã©lÃ©ment est visible dans le DOMexpect(locator).toContainText() permet dâaffirmer quâun Ã©lÃ©ment contient un certain texteexpect(locator).toHaveAttribute() permet dâaffirmer quâun Ã©lÃ©ment a un attribut avec une certaine valeurexpect(locator).toHaveCount() permet dâaffirmer quâun Ã©lÃ©ment est prÃ©sent un certain nombre de foisexpect(locator).toHaveText() permet dâaffirmer quâun Ã©lÃ©ment a un texte spÃ©cifiqueexpect(locator).toHaveValue() permet dâaffirmer quâun champ a une certaine valeurexpect(locator).toHaveTitle() permet dâaffirmer quâune page a un certain titreexpect(locator).toHaveURL() permet dâaffirmer quâune page a une certaine URLâÃ noter que tous les contraires sont possibles en ajoutant un .not devant chacune des mÃ©thodesOn veut Ã©galement pouvoir affirmer (assert en anglais) que quelque chose se passe bien comme prÃ©vu. Par exemple, aprÃ¨s avoir cliquÃ© sur le bouton, on sâattend Ã  ce quâune checkbox portant le label de notre To-do soit visible Ã  lâÃ©cran. Pour tester Ã§a, nous ferons :Dans ce snippet de code, on clique sur le bouton âValiderâ, puis on affirme que la checkbox portant le label âNouvelle tÃ¢cheâ ne soit pas cochÃ©e (normal, nous venons de la crÃ©er !).Si lâÃ©lÃ©ment portant le nom âNouvelle tÃ¢cheâ nâest pas visible Ã  lâÃ©cran, Playwright renverra une erreur explicite nous permettant de rÃ©soudre le problÃ¨me, si la checkbox est cochÃ©e au lieu dâÃªtre dÃ©cochÃ©e, Playwright nous renverra aussi une erreur explicite !Câest parti pour Ã©crire notre premier test !ð Essayez dâÃ©crire un test end-to-end dans le dossier tests qui teste la crÃ©ation de To-do.Il devra :AccÃ©der Ã  lâappSe connecterCrÃ©er un To-do avec la catÃ©gorie HomeAffirmer que la To-do a bien Ã©tÃ© crÃ©Ã©eâ[Indice 1] : Avez-vous pensÃ© Ã  naviguer vers lâapplication avant dâexÃ©cuter votre test ? Â La mÃ©thode goto sert justement Ã  Ã§aâ[Indice 2] : Il existe un localisateur pour localiser les Ã©lÃ©ments par placeholder : getByPlaceholderâ[Indice 3] : Nous pouvons utiliser getByRole pour accÃ©der aux boutonsâ[Indice 4] : Sur cette application, la faÃ§on de localiser la liste dÃ©roulante des catÃ©gories serait avec un getByRole, mais personnellement, je prÃ©fÃ¨re modifier le composant pour y ajouter un attribut arial-label et pouvoir le localiser avec un getByLabel. Â On amÃ©liore ainsi lâaccessibilitÃ© de lâapplication.ââ[SPOILER] : La solution âVÃ©rifions tout cela en lanÃ§ant les testsPour cela, il vous suffit dâexÃ©cuter cette commande Ã  la racine du projet :Les tests doivent passer et vous devriez voir cette sortie dans la console :ConclusionSi vous deviez retenir trois choses de cet article, vous retiendriez :Les tests end-to-end servent Ã  simuler les actions dâun utilisateurOn les utilise uniquement pour tester les parcours critiques dâune applicationIl faut utiliser les localisateurs de Playwright plutÃ´t que les sÃ©lecteurs JQueryPour aller plus loin :Visualiser les testsPour voir ce que Playwright fait en temps rÃ©el sur lâapplication, deux possibilitÃ©s : le mode UI de Playwrighten utilisant lâextension Playwright de VSCode, et en cochant lâoption âShow BrowserâââRapport HTMLQue vos tests soient tous passÃ©s ou non, Playwright gÃ©nÃ¨re un rapport HTML disponible dans le dossier playwright-report.Ce rapport contient de nombreuses informations utiles pour dÃ©bugger les tests qui ont Ã©chouÃ©.Il liste les tests, et si on clique sur un test, il affiche les actions effectuÃ©es et lâendroit oÃ¹ le test a Ã©chouÃ©.Le rapport affiche mÃªme le Trace Viewer qui permet dâafficher lâÃ©cran du navigateur pour mieux comprendre pourquoi le test a Ã©chouÃ©. Il contient des outils dÃ©veloppeurs avec les onglets Console, RÃ©seau et Source.Vous pouvez modifier la configuration Playwright pour modifier les options de sa gÃ©nÃ©ration.Pour le visualiser correctement, utilisez la commande suivante :âUn serveur web se lancera alors sur le port 9223 et vous accÃ¨derez Ã  un page comme celle-ci :âUn serveur web se lancera alors sur le port 9223 et vous accÃ¨derez Ã  un page comme celle-ci :Ã prendre quand mÃªme avec des pincettes, nâoubliez pas de repasser derriÃ¨re, la gÃ©nÃ©ration de code automatique nâest jamais parfaite !Pourquoi choisir Playwright ?Il existe de nombreuses librairies de tests mais jâai choisi de vous parler de Playwright pour plusieurs raisons :Playwright supporte tous les navigateurs modernes : Chromium (Chrome et Edge), Firefox et Webkit (Safari).Il est possible dâexÃ©cuter les tests Playwright depuis plusieurs plateformes : en local, dans la CI ainsi que sur Windows, Linux et macOS.Playwright permet dâÃ©crire les tests dans le language que lâon souhaite car il supporte Typescript, JavaScript, Python, .NET, C# et Java.Playwright fournit Ã©galement de nombreuses fonctionnalitÃ©s additionnelles qui amÃ©liorent lâexpÃ©rience des dÃ©veloppeurs (extension VSCode, gÃ©nÃ©ration de code, Trace Viewer, les rapports de test), jâen ai parlÃ© un peu plus tÃ´t dans cet article.Si les utilisateurs de votre application utilisent principalement un navigateur particulier, comme Chrome, et que les dÃ©veloppeurs de votre Ã©quipe travaillent avec JavaScript, Cypress peut Ãªtre une meilleure alternative en offrant un environnement de test plus ciblÃ©.Liens utilesDocumentation de Playwright : https://playwright.dev/docs/introVoici un article sur Cypress : https://www.sipios.com/blog-posts/how-to-create-readable-end-to-end-tests-with-cypress-and-cucumberCâest bon, vous Ãªtes fin prÃªts et Ãªtes devenus un hero en tests end-to-end ! JâespÃ¨re que lâarticle vous aura servi et que vous aurez pris du plaisir Ã  le lire !NâhÃ©sitez pas Ã  rÃ©agir Ã  lâarticle, Ã  le commenter ou Ã  me contacter si vous avez des questions !âCopyright Â©2023 TheodoÂ FinTech. Tous droits rÃ©servÃ©s.EquipeNous rejoindreContactTheodoPolitique de confidentialitÃ©Mentions lÃ©gales