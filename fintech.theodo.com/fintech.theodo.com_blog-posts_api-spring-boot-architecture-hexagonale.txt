Construire une API Spring Boot en utilisant lâArchitecture Hexagonale.
 Â Sipios devient TheodoÂ FinTech, lâentitÃ© experte Services Financiers du groupe Theodo 
ClientsOffresMobile Wealth ManagementFintechÂ Due DiligenceMVPÂ at scaleConception et design UX/UIProgramme d'APIsationFinTech as a serviceExpertisesReactJSOpen BankingSpring BootKotlinBlog

Tech

BusinessCarriÃ¨re

Equipe


Nous rejoindreContactConstruire une API Spring Boot en utilisant lâArchitecture Hexagonale.4 minutesMis Ã  jour le16/4/2024Share this postExplorez la conception d'une API REST avec Spring Boot selon l'Architecture Hexagonale, mettant en lumiÃ¨re les principes du Domain Driven Design. #HexagonalArchitecture#Spring Boot#API#JavaDorian FrancesSoftware EngineerPrÃ©sentation de lâAPIComment partir sur des bases solides lorsque lâon se lance dans la crÃ©ation dâune API REST en utilisant une architecture hexagonale ? Câest ce que nous allons essayer de construire tout au long de cet article !Le but est de se constituer une base de donnÃ©es de PokÃ©mons. Une sorte de pokÃ©dex si vous voulez. Pour cela, nous allons passer par lâAPI PokÃ©API. Pour celles et ceux qui ne voient pas ce quâest PokÃ©API, il sâagit simplement dâune API publique mettant Ã  disposition de nombreuses informations concernant les PokÃ©mons comme leur nom, leurs capacitÃ©s, leur espÃ¨ceâ¦Nous partirons dâun projet vide pour arriver Ã  une API fonctionnelle et correctement testÃ©e en passant par lâexplication des grands principes de lâarchitecture hexagonale. Cela dit, lâAPI que nous allons construire dans ce tutoriel ne justifie pas forcÃ©ment la mise en place dâune telle architecture. Elle sert simplement de support afin dâexpliquer les concepts et outils prÃ©sents dans cet article.Nous le verrons par la suite, mais il nâest pas toujours judicieux de choisir une architecture complexe comme lâarchitecture hexagonale pour lâensemble de vos projets !IMPORTANT â¡Pour simplifier la lecture, vous trouverez en cliquant sur ð ce lien, lâAPI servant de support Ã  cet article. Vous pourrez ainsi suivre au fil de lâeau lâensemble des concepts et des outils prÃ©sentÃ©s ici.Bonne lecture !GÃ©nÃ©rer le projetComme beaucoup de projets Ã©crits avec Spring Boot, nous pouvons utiliser le Spring Initializr pour gÃ©nÃ©rer notre projet. Voici donc les dÃ©pendances que nous allons ajouter.âEn ouvrant le projet ainsi gÃ©nÃ©rÃ©, vous pouvez lancer votre application via votre IDE ou en utilisant la commande suivante Ã  la source du projet : ./mvnw spring-boot:run.CrÃ©ation de la base de donnÃ©es locale via DockerPour pouvoir rÃ©aliser nos dÃ©veloppements en local, nous allons avoir besoin de nous gÃ©nÃ©rer une base de donnÃ©es. Nous allons donc utiliser Docker.Ã la source de notre projet, nous allons crÃ©er un fichier docker-compose.yml ayant pour contenu ce qui suit :âVous pouvez ensuite lancer la commande docker-compose up Ã  la source du projet afin de gÃ©nÃ©rer lâimage PostgreSQL de votre base de donnÃ©es qui va accueillir vos PokÃ©mons.Connecter notre application Ã  notre base de donnÃ©es PostgreSQL et lancer les migrationsNotre application est gÃ©nÃ©rÃ©e et prÃªte Ã  Ãªtre lancÃ©e. Nous avons une base de donnÃ©es tournant en local. Il nous faut maintenant connecter ces deux briques, mais Ã©galement faire en sorte quâau dÃ©marrage de notre API, les migrations de notre base de donnÃ©es se lancent afin que cette derniÃ¨re soit prÃªte Ã  Ãªtre utilisÃ©e. Et pour cela, nous allons utiliser lâoutil Liquibase.Connection avec la base de donnÃ©esCrÃ©ez ou modifiez votre fichier de configuration dâapplication pour indiquer Ã  Spring Boot quâil faut se connecter Ã  votre base de donnÃ©es.âNous avons ici crÃ©Ã© un fichier de configuration application-local.yml car Ã  terme, vous aurez sans doute diffÃ©rents environnements de dÃ©veloppement possÃ©dant chacun leur propre base de donnÃ©es.Vous pouvez relancer votre application, elle se connectera correctement Ã  votre base de donnÃ©es PostgreSQL.Lancer les migrationsDans le dossier src/main/resources nous allons crÃ©er ces deux fichiers :âLe premier nous permet dâindiquer les diffÃ©rents fichiers de migrations que nous possÃ©dons ainsi que lâordre dans lequel ils doivent Ãªtre exÃ©cutÃ©s. Le second est, lui, notre premier fichier de migration ! Nous crÃ©ons ici notre table pokemons ainsi que ses diffÃ©rentes colonnes.Enfin, la derniÃ¨re Ã©tape consiste Ã  indiquer Ã  Spring Boot oÃ¹ trouver les fichiers de migrations que nous voulons lancer au dÃ©marrage. Notre fichier de configuration doit donc se transformer comme cela :Relancez votre application. Elle se connectera Ã  votre base de donnÃ©es et vous pourrez vÃ©rifier en utilisant lâoutil de votre IDE ou par exemple DBeaver, que vos migrations ont bien Ã©tÃ© lancÃ©es.Les notions de domain, application, infrastructure et bootstrapÃa y est, notre API est prÃªte, nous pouvons commencer Ã  dÃ©velopper. Mais dâabord explication un peu thÃ©orique de ce que nous allons faire pour pouvoir mettre en Ã©vidence la notion dâarchitecture hexagonale.Tout dâabord, pourquoi mettre en place une telle architecture ? LâintÃ©rÃªt de lâarchitecture hexagonale apparait dans le cas dâune logique mÃ©tier complexe car elle isole naturellement le code que lâon veut tester en omettant toute dÃ©pendance technique. Ansi les tests sont faciles Ã  Ã©crire et le code complexe gagne en robustesse. De plus, si durant la vie du projet, lâenvie de changer une implÃ©mentation technique, comme notre base de donnÃ©es par exemple, se fait ressentir, le cost of change de cette dÃ©cision sera par consÃ©quent rÃ©duit.Notre application va se composer en 4 grands packages :Domain : nous devons mettre dans ce package lâensemble de notre code mÃ©tier. Autrement dit, le code avec de la valeur ajoutÃ©e. Nous y retrouverons nos objets mÃ©tiers, les mÃ©thodes de ces objets, etc. Ce package doit Ãªtre indÃ©pendant de toutes implÃ©mentations techniques (nous y reviendrons).Application : il reprÃ©sente toutes les implÃ©mentations techniques qui se base sur notre logique mÃ©tier. On pourra retrouver la dÃ©finition de notre API REST avec nos controllers, nos DTOsâ¦Infrastructure : il reprÃ©sente toutes les implÃ©mentations techniques sur laquelle est basÃ©e notre logique mÃ©tier. On y retrouvera les logiques de connection Ã  nos bases de donnÃ©es, nos entitÃ©sâ¦Bootstrap : câest lÃ  que lâon retrouve toutes les choses relatives Ã  lâinitialisation de notre application.Voici donc lâarborescence de notre application.Arborescence de lâAPIâLâimplÃ©mentation de notre premier endpointNous allons donc dÃ©finir notre controller permettant de rÃ©cupÃ©rer la liste des ID de pokÃ©mons que lâon ne possÃ¨de pas dÃ©jÃ  comme suit :Notre PokemonController Â (prÃ©sent dans notre package application) prend en dÃ©pendance notre service CapturablePokemonUseCase qui lui, fait parti de notre domain. Jusque-lÃ , rien dâanormale.On demande Ã  notre service UseCase de nous donner, parmi le top 20 des pokÃ©mons, ceux que lâon peut capturer.Nous mappons ensuite cette liste dâobjets vers notre DTO que lâon renvoie ensuite Ã  notre API.Maintenant, regardons ce quâil se passe du cÃ´tÃ© de notre service contenu dans le domain. Nous pouvons voir ceci :Nous comprenons globalement bien ce que fait ce service :Il rÃ©cupÃ¨re la liste des IDs de PokÃ©mons que lâon possÃ¨de dÃ©jÃ .Il rÃ©cupÃ¨re, via une API, le top 20 des PokÃ©mons disponibles.Il renvoie au controller, les PokÃ©mons que lâon ne possÃ¨de pas encore.Vous pouvez voir ici notre objet mÃ©tier (remarquez quâaucune annotation Spring n'est prÃ©sente dans notre domain).âPourquoi est-ce que lâon injecte des interfaces dans notre service ?Lâinversion de dÃ©pendanceVous vous souvenez quand je vous ai dit quâil fallait que notre domain soit complÃ¨tement indÃ©pendant de toutes implÃ©mentations techniques ? On y revient ici !Lorsque nous avons regardÃ© tout Ã  lâheure lâimplÃ©mentation de notre controller, je nâai pas fait mention de quelconque interface lorsque jâai dit que nous lui injections notre service. En effet, pour le cas du controller ce nâÃ©tait pas nÃ©cessaire. CâÃ©tait notre controller qui Ã©tait dÃ©pendant de notre service du domain.Dans le cas prÃ©sent, ce nâest pas le cas, câest notre domain (CapturablePokemonUseCase) qui dÃ©pend de PokemonApiFetcher et PokemonRepositoryFetcher et ces objets ne peuvent pas Ãªtre des implÃ©mentations techniques (rÃ¨gle de lâarchitecture hexagonale). Alors que sont ces objets ?La notion de ports et dâadaptersVous avez sÃ»rement dÃ©jÃ  entendu la notion dâArchitecture Ports & Adapters. Câest lâautre nom souvent donnÃ© Ã  lâArchitecture Hexagonale. Elle vient en rÃ©alitÃ© dâune mÃ©taphore toute simple de la construction de notre architecture.Comme notre domain ne peut pas Ãªtre dÃ©pendant dâimplÃ©mentations techniques qui lui sont extÃ©rieures, il nâinteragira quâavec des interfaces (faisant partie intÃ©grante du domain) que lâon appelle des ports. Ces interfaces seront ensuite implÃ©mentÃ©es par des classes faisant partie du package infrastructure. On appellera ces classes, des adapters.SchÃ©ma de reprÃ©sentation de notre architecture ports & adaptersâLes interfaces ne contiennent aucune logique, elles ne dÃ©finissent que la signature des mÃ©thodes que lâon veut utiliser. De plus, ces mÃ©thodes ont un nom âmÃ©tierâ, sans prendre en compte lâimplÃ©mentation technique choisie (par exemple capturePokemon).âAinsi, nous avons inversÃ© le sens de dÃ©pendance de notre domain par rapport aux diffÃ©rentes implÃ©mentations techniques. Ainsi, ce sont maintenant les adapters qui dÃ©pendent du domain.Le mapping des objets manipulÃ©sCertains dâentre vous lâauront sÃ»rement dÃ©jÃ  remarquÃ© mais, nous utilisons des Mapper dans lâimplÃ©mentation de notre controller, ainsi que dans nos adapters. Ã quoi peuvent-ils bien servir ?Il sâagit lÃ  encore dâune contrainte de lâarchitecture hexagonale. Lorsque lâon dit que notre domain doit Ãªtre indÃ©pendant de toutes classes rÃ©sidant en dehors de son pÃ©rimÃ¨tre, cela vaut Ã©galement pour les objets quâil manipule. Ainsi, notre domain ne peut pas manipuler des objets tels que des DTOs de rÃ©ponse de notre API, des entitÃ©s de notre base de donnÃ©esâ¦Nous devons donc crÃ©er des objets spÃ©cifiques Ã  notre domain et chaque passage de ces objets entre les packages application, infrastructure et domain doit se faire via des mappers. Vous trouverez un exemple ci-dessous :âLâinjection de dÃ©pendancesVous vous demandez sÃ»rement depuis tout Ã  lâheure pourquoi est-ce que nous nâavons pas encore parlÃ© du package bootstrap de notre application et vous auriez raison. En effet, notre domain est fonctionnellement indÃ©pendant du reste de notre application grÃ¢ce Ã  lâutilisation des diffÃ©rents mappers et les interfaces que nous lui fournissons en dÃ©pendance. Mais alors comment ces interfaces sont-elles injectÃ©es ?Pour les parties externes Ã  notre domain, nous utilisons les dÃ©corateurs Spring @RestController et @Component. Mais alors, pourquoi nâutilisons-nous pas le dÃ©corateur @Service sur les classes de notre domain ? Eh bienâ¦ pour ne pas rendre notre domain dÃ©pendant Ã  Spring Boot ! Je sais, câest discutable, mais câest tout de mÃªme intÃ©ressant de vous montrer comment faire et Ã§a se passe dans le package bootstrap.Nous rÃ©alisons donc lâensemble des injections de dÃ©pendances de notre domain âÃ  la mainâ.âRemarque : nous pourrions pousser cette notion et rÃ©aliser lâentiÃ¨retÃ© des injections de dÃ©pendances de lâapplication âÃ  la mainâ afin de rendre encore davantage notre application, agnostique de Spring Boot. Cela dit, posez-vous toujours la question âest-ce que câest nÃ©cessaire ?â.Nous voyons que cette injection peut Ãªtre contraignante, surtout si lâon doit le faire pour chacun des services de notre domain. Je vous mets donc ici un article permettant dâutiliser des annotations custom pour simplifier cette gÃ©nÃ©ration de @Bean tout en respectant les principes de lâarchitecture hexagonale. Lâexemple utilisant le language Kotlin, cet article vous aidera Ã  le transposer en Java.Et voilÃ , de cette maniÃ¨re, nous avons rendu notre domain (notre logique mÃ©tier) complÃ¨tement indÃ©pendant du reste de notre application ! ðTester notre applicationJe ne vous apprends rien en vous disant quâune bonne application est une application testÃ©e correctement. Dans ce cas, en quoi lâarchitecture hexagonale nous est utile ?SÃ©paration des responsabilitÃ©sLâarchitecture hexagonale nous force Ã  dÃ©finir des limites claires entre les diffÃ©rentes parties de notre application selon leur rÃ´le. Ce qui rend les tests unitaires et les tests dâintÃ©grations plus faciles Ã  Ã©crire et Ã  maintenir.Lâinjection de dÃ©pendancesLâarchitecture hexagonale favorise lâutilisation de lâinjection de dÃ©pendances pour fournir uniquement les ressources nÃ©cessaires aux diffÃ©rentes parties de notre application, les rendant Â plus modulaires et indÃ©pendantes. Cela facilite la substitution des dÃ©pendances par des versions fictives ou simulÃ©s lors des tests.Un exemple de test unitairesUn exemple de test dâintÃ©grationLe but dâun test dâintÃ©gration est de vÃ©rifier que lâensemble des parties de notre application fonctionnent correctement ensemble.Afin de simuler ce que nous renvoie lâAPI PokÃ©API, nous allons utiliser Wiremock. Vous trouverez toute la configuration nÃ©cessaire sur le repo du projet, que je ne vais pas dÃ©tailler ici.Nous pouvons donc Ã©crire notre test dâintÃ©gration de la sorte :âArchunit et les rÃ¨gles architecturalesJe tenais Ã  vous prÃ©senter rapidement cette librairie assez utile quâest Archunit. Il sâagit dâune librairie Java open-source permettant d'Ã©crire des tests unitaires pour vÃ©rifier la conformitÃ© de votre architecture. Vous pouvez Ã©crire des rÃ¨gles de nommage pour certaines classes, mais dans notre cas, le plus intÃ©ressant reste tout de mÃªme les rÃ¨gles dâarchitecture de code.LâÃ©criture de ce type de tests parle dâelle-mÃªme ! Avec le dÃ©corateur @AnalyzeClasses, nous renseignons les classes sur lesquelles nous voulons vÃ©rifier nos diffÃ©rentes rÃ¨gles. Câest en utilisant le dÃ©corateur @ArchTest que nous explicitons Ã  Junit que nous dÃ©finissons une mÃ©thode comme une rÃ¨gle Archunit qui sera ensuite analysÃ©e lorsque nous lancerons nos tests.Pour rÃ©sumerJe nâai pas explicitÃ© lâentiÃ¨retÃ© du dÃ©veloppement des diffÃ©rentes fonctionnalitÃ©s de notre application, mais comme vous pouvez le voir, il y avait tout mÃªme dÃ©jÃ  beaucoup de choses Ã  dire.Je tiens quand mÃªme Ã  vous rappeler quâil est important de toujours se demander âest-ce que jâai rÃ©ellement besoin de mettre en place une architecture hexagonale ?â. En effet, on se rend trÃ¨s vite compte que lâarchitecture hexagonale peut Ãªtre trÃ¨s, parfois trop, contraignante. On crÃ©Ã© de nombreuses classes afin de rester dans les clous, on mappe Ã©normÃ©ment dâobjets entre les diffÃ©rentes parties de notre applicationâ¦ et cela peut occasionnellement demander quelques efforts dâabstractions.Comme mentionnÃ© Ã  plusieurs reprises, nous faisons Ã©normÃ©ment dâeffort pour dâisoler la logique mÃ©tier des autres parties de notre application. Ce genre dâarchitecture se prÃªte donc gÃ©nÃ©ralement Ã  des applications avec Ã©normÃ©ment de logique mÃ©tier.Vous allez me dire que je nâai pas nÃ©cessairement pris comme exemple, lâapplication la plus propice Ã  ce genre dâarchitecture et vous auriez raison. J'espÃ¨re que grÃ¢ce Ã  cet article et Ã  cette API simple, vous avez pu apprendre et comprendre les bases de lâarchitecture hexagonale.Ici, nous nous sommes concentrÃ© sur lâimplÃ©mentation concrÃ¨te dâune architecture hexagonale. Cependant, si vous voulez dâavantage creuser les erreurs types et les diffÃ©rentes piÃ¨ges dans lesquels il ne faut pas tomber lorsque lâon met en place ce type dâarchitecture, je vous invite Ã  lire cet article qui couvre dâavantage ces points.âCopyright Â©2023 TheodoÂ FinTech. Tous droits rÃ©servÃ©s.EquipeNous rejoindreContactTheodoPolitique de confidentialitÃ©Mentions lÃ©gales